Attempto Controlled English
===========================

1. Intro sur l'analyse linguistique (prolog, linguistique), anglais controlé, etc...
------------------------------------------------------------------------------------

Enfance de l'art
++++++++++++++++

Depuis la naissance de l'ordinateur à la fin des années 1940, nombre d'ingénieurs et chercheurs rêvent d'apprendre à celle-ci de comprendre notre langage humain.
Passé l'optimisme des premières années, les travaux ont trouvés une première réussite au début des années 1970, avec entre autre la naissance de Prolog.[1]

En 1970, on arrivait, grâce à Prolog, à dialoguer de la manière suivante avec la machine :
 *Utilisateur*
 Les chats tuent les souris.
 Minou est un chat qui n'aime pas les souris qui mangent du fromage. Miquette est une souris qui mangent du fromage.
 Max n'est pas une souris.
 Que fait Minou?
 *Machine*
 Le Minou ne aime pas les souris qui mangent le fromage.
 Le Minou tue les souris.

Les bases de raisonnement logique sont là, mais c'est encore spartiate…

Prolog étant devenu le langage C de l'IA, il va vite être à la base de nombreux traveaux d'analyse linguistique, d'abord formel, puis assez vite statistique grâce à la puissance informatique disponible dès les années 1980.

[L'une des principales difficulté du traitement du langage humain est l'analyse des ambiguité ....]



Dans cette article, nous allons présenter un anglais contrôlé Attempto Controlled English et son parseur, et nous allons montrer comment l'utiliser pour générer du code source à partir d'une description en anglais d'une interface utilisateur.





Approches d'analyse
+++++++++++++++++++

L'analyse linguistique formelle consiste à définir un corpus grammatical et un vocabulaire ainsi qu'un ensemble de règles permettant au programme d'analyser le code. Cette approche nécessite un long et fastidieux travail de formalisation, et n'a aucune résistance aux fautes d'orthographes, aux tournures de phrases peu courantes, etc...
Malgré ce gros défaut, l'analyse formelle permet de contrôler plus rigoureusement le sens de ce qui est analysé, c'est donc un choix privilégié lorsque l'on souhaite faire de l'analyse logique de la langue

En réaction, l'approche statistique consiste à utliser des algorithmes d'apprentissage - Machine Learning en anglais - pour réaliser de l'analyse ou de la traduction. C'est l'approche utilisé pa rla plupart des logiciels de traduction automatiques, dont celui de Google (c'est la raison pour laquelle il vous propose de l'aider gratuitement à améliorer son moteur en amémiorant sa traduction).
Cette approche est plus souple, car il suffit de "l'entrainer" avec un certain nombre de texte traduit par l'homme pour lui apprendre à se débrouiller seule.
De par son approche flou, elle est surtout utilisé pour de la traduction automatique, de l'analyse de sens ou tout autre approche souffrant d'une certaine marge d'erreur dans l'exactitude.

Les langues controlées
++++++++++++++++++++++

L'analyse linguistique est un sujet maintenant bien assimilé par la communauté des chercheurs en traitement automatique de la langue (TAL), à tel point qu'elle est souvent enseignée dès le Master I aux étudiants.
L'analyse formelle a survécu en se spécialisant dans les langues contrôlées : plutôt que de tenter de formaliser *toutes* les possibilités d'un langage, on en défini un sous ensemble, assez vaste pour être utilisable, mais assez restreinte pour ne pas devenir impossible à analyser.

Parmi tous les langues controllées, nous en avons choisi une - Attempto Controlled English - qui a plusieurs particularités intéressantes, mais dont la première est de proposer un parseur libre (LGPL).


2. Expliquer ce qu'est Attempto : LGPL, un anglais contrôlé, avec partie pris de n'analyser que la syntaxe
---------------------------------------------------------------------------------------------------------- 

Attempto Controlled English [2] (ACE) est un projet créé par Norbert E. Fuchs à l'Université de Zurich en 1995. 
L'objectif d'ACE est de proposer un anglais contrôlé *non ambigüe* qui soit en même temps un langage permettant d'exprimer directement de la logique du premier ordre. Attempto est en fait un langage logique du premier ordre… en anglais.
La grammaire d'ACE, bien qu'assez vaste, est très strictement définie. Bien évidemment, aucune faute d'orthographe n'est permise. Toute ambiguité potentiel est soit éliminé de la grammaire, soit fait l'objet d'un parti pris défini clairement. Toute phrase aura une et une seule interprétation possible.

ACE ne travaille que sur la syntaxe : seule la nature grammatical des mots et la structure grammaticale de la phrase sert à l'analyse. On évite ainsi l'utilisation d'une ontologie qui peut être sujet à caution.
Le vocabulaire d'ACE est définissable et extensible à l'infini : il suffit d'indiquer dans le lexique si le mot est un nom commun (et en passant d'indiquer son pluriel), un adjectif, etc...

Le parseur d'Attempto, Attempto Parser Engine (APE) est un outil écrit en prolog (dans le dialecte de Swi-prolog, un prolog libre disponible sur toutes les distributions connues), utilisable en ligne de commande, voire en tant que webservice.
APE peut renvoyer l'analyse qu'il effectue du texte qui lui est donné dans différents formats - dont le format Semantic Web Rule Language  (SWRL), défini par le W3C [3])
Dans la suite de l'article, nous utiliserons néanmoins le format "Discourse Representation Structure", étendue par l'équipe du Pr Fuchs pour les besoins du logiciel, et qui s'avère plus puissante et étendue que le SWRL.

Cette structure de donnée DRS est un arbre avec une grammaire clairement définie et facile à utiliser. DRS est un format puissant permettant d'exprimer de la logique du premier ordre classique et de la logique modale (déontique et aléthique) de par les opérateurs CAN et MUST.
On verra par la suite un analyseur de DRS écrit en OCaml, permettant d'analyser ce DRS et d'en faire à peu près ce que l'on veut.


3. Premier contact Attempto
---------------------------

Attempto nécessite l'installation de Swi-Prolog.

Sur une Debian, on l'installera facilement celui-ci :

 apt-get install swi-prolog


Après avoir téléchargé APE sur le site [1], l'installation non conventionelle se fait au moyen d'un ./make_exe.sh dans son répertoire.

Analysons une première phrase, qui s'avère être une règle :


::

  $ ./ape.exe  -cparaphrase   -cdrs -guess -text 'If the last character of S is not "/" then Prog appends "/" to S.'
  <?xml version="1.0" encoding="UTF-8"?>
   <apeResult>
     <duration tokenizer="0.028" parser="0.007" refres="0.001"/>
     <drs>drs([],[=&gt;(drs([A,B],[relation(A,of,B)-1/5,property(A,last,pos)-1/3,object(A,character,countable,na,eq,1)-1/4,-(drs([C],[predicate(C,be,A,string(/))-1/7])),object(B,something,dom,na,na,na)-1/6]),drs([D],[predicate(D,append,named('Prog'),string(/))-1/12,modifier_pp(D,to,B)-1/14]))])</drs>
     <paraphrase>If there is a last character X1 of something X2 and it is false that the last character X1 is "/" then Prog appends "/" to X2.</paraphrase>
     <messages>
      <message
        	importance="warning"
  	        type="word"
  		sentence="1"
  		token="11"
  		value="Prog"
  		repair="Undefined word. Interpreted as a singular proper name."/>
      <message
  	importance="warning" type="anaphor" sentence="1" token="4" value="The definite noun phrase 'the character' does not have an antecedent and thus is not interpreted as anaphoric reference, but as a new indefinite noun phrase." repair="If the definite noun phrase 'the character' should be an anaphoric reference then you must introduce an appropriate antecedent."/>
    </messages>
  </apeResult>



Ape génère une petite structure XML sur la sortie standard contenant des informations temporelles, le DRS produit, et une phrase reconstruite à partir du DRS produit.
Dans un langage un peu plus verbeux, on constate que cela veut dire la même chose que la phrase d'origine.


Avant d'analyser l'anglais d'ACE et le DRS, voici quelques options intéressantes d'APE :
	- cparaphrase : propose une paraphrase du texte entré reconstruite par APE à partir du DRS qu'il produit. cela permet de contrôler qu'on est d'accord avec APE sur le sens de notre phrase
	- cdrs sort une structure d'analyse en format DRS
	- guess permet de deviner la nature grammatical d'un mot inconnu dans le lexique
	- httpserver permet de transformer APE en serveur web sur le port 8000, l'option -port permet de défiir son port


4. L'anglais d'Attempto
-----------------------


Dans ACE, tout verbe s'écrit à la troisième personne du singulier au présent et à la voix active. On peut dans certains cas utiliser la voix passive, mais on tombe vite sur les frontières du langage.
Dans toutes les langues du monde, les verbes sont intransitif (pleuvoir), transitifs (manger), bitransitifs (donner). 
Dans le premier cas, on a qu'un sujet un verbe, dans le second, un sujet un verbe un complément, et dans le troisième un deuxième complément (Donner quelques chose à quelqu'un).

Phrases simple :
	- *Jean loves Mary.* drs([A],[predicate(A,love,named('Jean'),named('Mary'))-1/2])
	- *Jean gives a flower to Mary.* drs([A,B],[object(A,flower,countable,na,eq,1)-1/4,predicate(B,give,named('Jean'),A,named('Mary'))-1/2])*

Phrases avec adjectifs :
	- *Jean gives a beautiful blue flower to Mary.* drs([A,B],[object(A,flower,countable,na,eq,1)-1/5,property(A,blue,pos)-1/4,predicate(B,give,named('Jean'),A,named('Mary'))-1/2])

Attempto refuse un deuxième adjectif : *Jean gives a beautiful blue flower to Mary.* provoque une erreur


Phrases un peu plus complexe :
	- *A country which has a river which has 2 forests borders a country of John.*


Règles :
	*Every flower that Jean gives to Mary implies that Mary is happy.*
	*Every flower that Jean gives to Mary can imply that Mary is happy.* On exprime ici une modalité


Je vous invite à lire le manuel d'Attempto pour comprendre la syntaxe autorisée. 
Si néanmoins cela vous fatigue et que vous souhaitiez tenter l'essai erreur, un conseil : surabusez des *that* et des *which* dans vos phrases !


5. Le Discourse Representation Structure
----------------------------------------

Le DRS est un format défini par une grammaire stricte, évidemment récursive, permettant d'exprimer sans ambiguité une définition ou règle logique de manière non ambigue.

Avant d'étudier sa structure, nous allons expliciter les primitives importantes :

- predicate  définit un verbe, intransitif, transitif, ou bitransitif. 
	Son premier paramètre est la variable le définissant, le second paramètre est le verbe à l'infinitif, le troisième est le sujet de ce verbe, le quatrième - dans le cas d'un verbe transitif et bitransitif - le complément, et le deuxième complément du verbe bitransitif s'il y a lieu.
	Ainsi *predicate(A,love,named('Jean'),named('Mary'))* se lit *Jean loves Mary*

- Object   : définit généralement un nom, commun ou propre. Le 1er paramètre est la variable le définissant, le 2nd le nom en lui même, le 3ème un terme définissant s'il est dénombrable ou non, un 4ème s'il a une unité de mesure, le 5ème s'il est égal, supérieur, inférieur, etc.. au 6ème paramètre.
		*object(A,flower,countable,na,eq,1)* Définit une variable A comme étant une fleur, qui est un objet dénombrable, sans unité de mesure (na), d'exactement un élément

- Property : définit qu'un objet représenté par la variable A a pour adjectif blue.property(A,blue,pos). 
		 pos signifie que l'on applique simplement l'adjectif au nom. Si l'on avait écrit *Jean gives a bluer flower to Mary.*,  on aurait property(A,blue,comp) qui indique une comparaison.

Chaque DRS peut contenir un ou plusieurs DRS avec des opérateurs, ou une liste de primitives précédemment définies. On verra dans la section suivante, la grammaire complète des DRS.

La plupart des phrases sont structurés sous la forme sujet + verbe [+ complément d'objet direct] [+ complément d'objet indirect], à l'aide des primitives object et predicate. Ces structures simple nous suffiront pour le moment.

6. DRS Analysis Tool
--------------------

DRS Analysis Tool est une petite librairie en OCaml, disponible sur github [4], permettant de parser la structure de donné DRS renvoyée par APE. 
On dispose ainsi d'un AST (Abstract Syntax Tree) utilisable directement en Ocaml.
Dans le fichier syntaxe.ml, on y trouve une définition de la grammaire du DRS dans un type OCaml :

::

 (* Un DRS est contitué d'un domaine - une liste de variables - et du corps du DRS proprement dit*)
 type fulldrs = FullDRS of domain * conditions

 (* Une condition est une liste d'atome*)
 and conditions = atom list
 and domain = var list

 (* Une variable peut être une variable seule, un sous atome, un nombre ou une chaine*)
 and var = Var of string | SubAtom of atom | Num of int | ConstStr of name

 (* on définit ici toutes les primitives de base : adjectif, préposition, verbe, adverbe, noms...*)
 and adjectif = Adj of name
 and adverbe = Adv of name
 and preposition = Preposition of name
 and verbe = Verbe of name
 and noun = Nom of name
 
 and pronom_interrogatif = Who | What | Which | How | Where | When
 and classtype = Dom | Mass | Countable

 (* 2 unités prise en compte : masse et distance*)
 and unittype = Kg | Na | Meter

 (* Opérateurs de comparaison*)
 and op = Eq | Geq | Greater | Leq | Less | Exactly | NaOp 
 and degre = Pos | Pos_as | Comp | Comp_than | Sup
 and compTarget = Subj | Obj
 and countable = NotCountable | Number of int

 and grammaticalNumber = Plural | Singular | Partitive
 (* Le coeur de la grammaire *)
 and atom = 
 
 (* *)
 | Operator2 of operator * fulldrs * fulldrs 
 | Operator1 of operator * fulldrs  

 | PredicateIntransitive of var * verbe * var * grammaticalNumber
 | PredicateTransitive of var * verbe * var * var * grammaticalNumber
 | PredicateDiTransitive of var * verbe * var * var * var * grammaticalNumber
 
 | Object of var * noun * classtype * unittype * op * countable (*Ref,Noun,Class,Unit,Op,Count*) * int * int 
 
 
 | Property1Ary of var * adjectif * degre 
 | Property2Ary of var * adjectif * degre * var
 | Property3Ary of var * adjectif * var * degre * compTarget * var
 
 
 | Relation of var * var
 | Modifier_Adv of var * adverbe * degre 
 | Modifier_pp of var * preposition * var
 
 | HasPart of var * var
 | PartOf of var * var 
 | Named of  name (**)
 | String of  name
 
 | Query of var * pronom_interrogatif
 | Rien ;;


Utilisation
+++++++++++


On peut disposer de l'AST d'un DRS en utilisant le REPL OCaml. Le projet est configuré pour utiliser Utop, un REPL amélioré (proposant entre autre un historique et la complétion).

::
  $ make top
 

  utop version 1.2.1 (using OCaml version 4.00.0)

  $ parsecomplete "drs([A],[predicate(A,love,named('Jean'),named('Mary'))-1/2]).";;
	- : Syntax.fulldrs = FullDRS ([Var "A"], [PredicateTransitive (Var "A", Verbe "love", SubAtom (Named "Jean"), SubAtom (Named "Mary"), Singular)])


  $ parsecomplete "drs([],[=&gt;(drs([A,B],[object(A,flower,countable,na,eq,1)-1/2,predicate(B,give,named('Jean'),A,named('Mary'))-1/5]),drs([],[can(drs([C,D],[predicate(C,imply,A,D)-1/9,D:drs([E,F],[property(E,happy,pos)-1/13,predicate(F,be,named('Mary'),E)-1/12])]))]))]).";;

    - : Syntax.fulldrs = FullDRS ([], 
	[Operator2 (Imply,FullDRS ([Var "A"; Var "B"],
    		[ Object (Var "A", Nom "flower", Countable, Na, Eq, Number 1, 1, 2); 
	       	  PredicateDiTransitive (Var "B", Verbe "give", SubAtom (Named "Jean"), Var "A", SubAtom (Named "Mary"), Singular)]),
	          FullDRS ([],
    				[Operator1 (Can,
					      FullDRS ([Var "C"; Var "D"],
						       [PredicateTransitive (Var "C", Verbe "imply", Var "A", Var "D", Singular);
						        SubDrs ("D", FullDRS ([Var "E"; Var "F"], 
										[Property1Ary (Var "E", Adj "happy", Pos); 
										 PredicateTransitive (Var "F", Verbe "be", SubAtom (Named "Mary"), Var "E", Singular)
										]
									     )
								)
							]
			      			     )
			   		  )
	 	 		]
			  )
	 	   )
	]
     )


7. Générer du code à partir d'une phrase
----------------------------------------


Introduction au pattern matching ocaml
++++++++++++++++++++++++++++++++++++++


Une fois le DRS parsé, nous allons pouvoir inférer ce que l'on désir à partir de l'arbre syntaxique obtenu.
Pour ce faire, nous allons user et abuser d'une fonctionnalité majeure d'OCaml (et de ses cousins Scala et Haskell) : le pattern matching.
Le pattern matching est une sorte de switch case dopé aux stéroïdes. Si vous êtes habitués aux Enums de Java, disons que c'est la possibilité de donner des paramètres à enum et de se définir récursivement.

Un expression mathématique du genre (5 + 9) - 5 peut s'écrire très facilement avec un type somme :
type expre =
| Plus of expre * expre
| Moins of expre * expre
| Nbr of int

Ainsi (5 + 9) - 5 s'écrit Moins( Plus(Nbr 5, Nbr 9), Nbr 5), ce que l'on appelle une notation polonaise inversée.
Une calculatrice s'écrit alors très simplement grace au pattern matching

let rec calc expression =
match expression with
| Plus (a,b) -> calc a + calc b
| Moins(a,b) -> calc a - calc b
| Nbr   a    -> a
Caml nous répond en typant cette fonction : val calc : expre -> int = <fun>


Une des grandes forces d'Ocaml (et d'Haskell) est sa capacité à vous gronder s'il manque un cas.
Ainsi, si l'on oubliait le cas  "plus" :
let rec calc expression =
match expression with
| Moins(a,b) -> calc a - calc b
| Nbr   a    -> a

Warning 8: this pattern-matching is not exhaustive. Here is an example of a value that is not matched: Plus (_, _)


On peut écrire toutes sorte de pattern matching : on peut par exemple capturer des formes d'arbres particulières, du genre Plus(Moins( Nbr 5, a), Nbr b) , le compilateur continuera à vérifier que le "switch/case" reste exhaustif.




8. Quel code génerer ?
----------------------

Mini grammaire permettant de génerer une interface et quelques règles.
Définition de la grammaire cible


Boite de dialogue
+++++++++++++++++

:: 

 <div id="dialog" title="Basic dialog">
  <p>This is the default dialog which is useful for displaying information. The dialog window can be moved, resized and closed with the 'x' icon.</p>
 </div>

::

 function dialogAppear(id) {
 	$( id ).dialog();
  }

type widget = 
| DialogSimple of nom * contenu 
| DialogForm  of  nom * contenu * height * width * bool * (string * fonction) list
| Slider      of  nom * int * int * fonction 


type fonction = Fonction of nom option * var list * expre list * expre (* nom, params, expres contenus, return*) 
and
expre =
| Length of expre 
| Str of string
| Nbr of string
| Bool of bool
| Re  of string 
| Affect of var * expr
| ReMatchVar of var * var
| StringEqual of expre * expre
| NbrEqual    of expre * expre
| BoolEqual   of expre * expre
| Show    of nom * widget (* nom du widget *)
| Nop
| If  of expre * expre * expre (* Attention, c'est une expression*)

exemple
function checkNumDeTel(tel) {
 var re = /[0-9] [0-9]{2} [0-9]{2} [0-9]{2} [0-9]{2}$/;
 return re.test(tel);
}

Fonction (Some "checkNumDeTel",["tel"],[Affect("re",Re "[0-9] [0-9]{2} [0-9]{2} [0-9]{2} [0-9]{2}$")], ReMatchVar("re","tel")
 

Slider
++++++

::
  <div id="slider"></div>

  function sliderAppear(id,slideFunc) {
    $( id ).slider({slide:slideFunc});
    }


| Slider of nom * min * max * fonction



9. Génération
-------------

Petit Programme
+++++++++++++++

On défini un Slider allant de 1 à 3, chaque déplacement affiche un dialog qui affiche un message

let widgets = [
	Slider ("slider1",1,3, Fonction(None, ["idx"], [ Show "dialogSlideCHange"], Nop) );
	DialogSimple ("dialogSlideCHange", "Le slider a été modifié")
];;

let program = [
Show ("slider1","slider");
]


Doit génerer

<html lang="en">
<head>
<meta charset="utf-8" />
<title>jQuery UI Slider - Snap to increments</title>
<link rel="stylesheet" href="http://code.jquery.com/ui/1.10.1/themes/base/jquery-ui.css" />
<script src="http://code.jquery.com/jquery-1.9.1.js"></script>
<script src="http://code.jquery.com/ui/1.10.1/jquery-ui.js"></script>
<link rel="stylesheet" href="/resources/demos/style.css" />
<script>
$(function() {
 $( "#slider" ).slider({
	value:0,
	min: 1,
	max: 3,
	slide: function( event, ui ) {
		$("#dialogSlideCHange").dialog();
	}
	});
});

</script>
</head>
<body>
	<div id="slider"></div>
	<div id="dialogSlideCHange" title="Basic dialog">
		<p>This is the default dialog which is useful for displaying information. The dialog window can be moved, resized and closed with the 'x' icon.</p>
	</div>
</body>
</html>


le générateur
+++++++++++++

let entete = "...";;
let build_onload core = 	Printf.sprintf "$(function() { \n %s\n }";;



let rec to_widget_js code = match code with
| Fonction  (nom, varlist, exprelist, expreReturn) -> k
and to_widgt wdgt = match wdgt with
| 
and to_expre =
| Length  expre -> (to_expre expre)^".length"
| Str s         -> s
| Nbr i   	-> string_of_int i 
| Bool b        -> string_of_bool b
| Re s 		-> "/"^s^"/"
| Affect (v,e)  -> v ^" = "^(to_expre e)^";"
| ReMatchVar(v,v2) 	-> v^".test("^v2^")"
| StringEqual (e1,e2) 	-> e1^" === "^e2
| NbrEqual    (e1,e2) 	-> e1^" === "^e2
| BoolEqual   (e1,e2) 	-> e1^" === "^e2
| Show    (nom,wdgt)  	-> let widget = match typew with
					| Slider _ -> "slider"
					| DialogSimple _ -> "dialog"
					| DialogForm   _ -> "dialog" in
			   let declare_wdgt = declare_widget wdgt in 
		Printf.sprintf " $('#%s').%s(\n\t%s\n\t)" nom widget wdgt 
| Nop  -> ""
| If  (test,if_case,else_case) -> Printf.sprintf  " (%s) ? %s : %s;" (to_expre test) (to_expre if_case) (to_expre else_case)

and  declare_widget w = 
	match w with
| Slider (nom, min, max, code) -> Printf.sprintf  "{ min:%s, max:%s , slide: %s } (string_of_int min) (string_of_int max) (to_js)
| DialogSimple of nom * contenu 
| DialogForm  of  nom * contenu * height * width * bool * (string * fonction) list


Objectif
++++++++

Petite appli

On utilise un slider qui dans certaines configurations autorise certaines choses 

Génération basique
Le cas des règles


[1] http://prolog.developpez.com/tutoriels/alain-colmerauer/histoire-prolog/


[2] http://attempto.ifi.uzh.ch/site/

[3] http://www.w3.org/Submission/SWRL/

[4] https://github.com/ontologiae/DRS-Analysis-Tool
